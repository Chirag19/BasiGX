<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* Copyright (c) 2016-present terrestris GmbH &amp; Co. KG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid'>/**
</span> *  A grid showing results of the multisearch WFS search response values.
 *  inspired by BasiGX.view.container.WfsSearch
 *  This class is used by BasiGX.view.form.field.MultiSearchCombo
 *
 * @class BasiGX.view.grid.MultiSearchWFSSearchGrid
 *
 * @extends Ext.grid.Panel
 *
 * @requires GeoExt.component.FeatureRenderer
 * @requires GeoExt.data.store.Features
 * @requires BasiGX.util.Map
 * @requires BasiGX.util.Layer
 * @requires BasiGX.util.Animate
 *
 */
Ext.define('BasiGX.view.grid.MultiSearchWFSSearchGrid', {
    extend: 'Ext.grid.Panel',
    xtype: 'basigx-grid-multisearchwfssearchgrid',

    requires: [
        'GeoExt.component.FeatureRenderer',
        'GeoExt.data.store.Features',
        'BasiGX.util.Map',
        'BasiGX.util.Layer',
        'BasiGX.util.Animate'
    ],

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-viewModel'>    viewModel: {
</span>        data: {
            title: 'Objektsuche'
        }
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-bind'>    bind: {
</span>        title: '{title}'
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-store'>    store: null,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-cls'>    cls: 'search-result-grid',
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-searchResultVectorLayer'>    searchResultVectorLayer: null,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-collapsible'>    collapsible: true,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-titleCollapse'>    titleCollapse: true,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-collapseDirection'>    collapseDirection: 'top',
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-headerPosition'>    headerPosition: 'left',
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-hideHeaders'>    hideHeaders: true,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-maxHeight'>    maxHeight: 180,
</span>
    config: {

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-combo'>        combo: null,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-minSearchTextChars'>        minSearchTextChars: 3,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-typeDelay'>        typeDelay: 300,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-allowedFeatureTypeDataTypes'>        allowedFeatureTypeDataTypes: [
</span>            'xsd:string'
        ],

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-searchTerm'>        searchTerm: null,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-map'>        map: null,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-layer'>        layer: null,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-searchResultFeatureStyle'>        searchResultFeatureStyle: new ol.style.Style({
</span>            image: new ol.style.Circle({
                radius: 6,
                fill: new ol.style.Fill({
                    color: '#4990D1'
                }),
                stroke: new ol.style.Stroke({
                    color: '#fff',
                    width: 2
                })
            }),
            stroke: new ol.style.Stroke({
                color: '#4990D1',
                width: 4
            })
        }),

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-searchResultHighlightFeatureStyle'>        searchResultHighlightFeatureStyle: new ol.style.Style({
</span>            image: new ol.style.Circle({
                radius: 8,
                fill: new ol.style.Fill({
                    color: '#EE0000'
                }),
                stroke: new ol.style.Stroke({
                    color: '#fff',
                    width: 2
                })
            }),
            stroke: new ol.style.Stroke({
                color: '#EE0000',
                width: 6
            })
        }),

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-searchResultSelectFeatureStyle'>        /**
</span>         *
         */
        searchResultSelectFeatureStyle: new ol.style.Style({
            image: new ol.style.Circle({
                radius: 10,
                fill: new ol.style.Fill({
                    color: '#EE0000'
                }),
                stroke: new ol.style.Stroke({
                    color: '#fff',
                    width: 2
                })
            }),
            stroke: new ol.style.Stroke({
                color: '#EE0000',
                width: 8
            })
        }),

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-flashStyle'>        flashStyle: function() {
</span>            return [new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 5
                })
            })];
        }

    },


<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-features'>    /**
</span>    *
    */
    features: [{
        ftype: 'grouping',
        groupHeaderTpl: 'Layer: {name}'
    }],

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-columns'>    /**
</span>    *
    */
    columns: [
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-'>              /**
</span>               * @todo gx_renderer doesn't render all features every time
               */
//        {
//            xtype: 'widgetcolumn',
//            flex: 1,
//            widget: {
//                xtype: 'gx_renderer'
//            },
//            onWidgetAttach: function(column, gxRenderer, record) {
//                // update the symbolizer with the related feature
//                var feature = record.getFeature();
//                gxRenderer.update({
//                    feature: feature,
//                    symbolizers: this.up('grid').getSearchResultFeatureStyle()
//                });
//            }
//        },
        {
            text: 'Feature',
            dataIndex: 'displayfield',
            flex: 5,
            renderer: function(value) {
                return '&lt;span data-qtip=&quot;' + value + '&quot;&gt;' +
                value + '&lt;/span&gt;';
            }
        }
    ],

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-initComponent'>    /**
</span>    *
    */
    initComponent: function() {
        var me = this;

        me.callParent(arguments);

        me.map = BasiGX.util.Map.getMapComponent().getMap();

        if (!me.searchResultVectorLayer) {
            me.searchResultVectorLayer = new ol.layer.Vector({
                name: 'Object Search Results',
                source: new ol.source.Vector(),
                style: me.getSearchResultFeatureStyle(),
                hoverable: false
            });

            var displayInLayerSwitcherKey =
                BasiGX.util.Layer.KEY_DISPLAY_IN_LAYERSWITCHER;
            me.searchResultVectorLayer.set(displayInLayerSwitcherKey, false);
            me.map.addLayer(me.searchResultVectorLayer);
        }

        var searchResultStore = Ext.create('GeoExt.data.store.Features', {
            map: me.map,
            layer: me.searchResultVectorLayer,
            groupField: 'featuretype'
        });

        me.setStore(searchResultStore);


        me.on('describeFeatureTypeResponse', me.getFeatures);
        me.on('getFeatureResponse', me.showSearchResults);

        // add listeners
        me.on('boxready', me.onBoxReady, me);
        me.on('itemmouseenter', me.highlightFeature, me);
        me.on('itemmouseleave', me.unhighlightFeature, me);
        me.on('itemclick', me.highlightSelectedFeature, me);
        // unregister listeners on grid hide
        me.on('hide', me.unregisterListeners, me);

    },


<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-describeFeatureTypes'>    /**
</span>     * Called by BasiGX.view.form.field.MultiSearchCombo.doObjectSearch()
     * This method starts the search by requesting the WFS-DescribyFeatureType
     * for all wanted layers.
     *
     * @param {string} searchterm The search term
     * @param {Ext.form.field.Combo} combo The calling combobox to set it on the
     *     WFSGrid
     */
    describeFeatureTypes: function(searchterm, combo) {
        var me = this;
        var typeNames = [];
        var featureTypes;

        me.searchResultVectorLayer.getSource().clear();

        me.setSearchTerm(searchterm);

        me.setCombo(combo);

        var searchLayers = combo.getConfiguredSearchLayers();

        Ext.each(searchLayers, function(l) {
            if (l.getSource().getParams) {
                typeNames.push(l.getSource().getParams().LAYERS);
            }
        });

        var describeFeatureTypeParams = {
            REQUEST: 'DescribeFeatureType',
            SERVICE: 'WFS',
            VERSION: '1.1.0',
            OUTPUTFORMAT: 'application/json',
            TYPENAME: typeNames.toString()
        };

        me.setLoading(true);

        Ext.Ajax.request({
            url: combo.getWfsServerUrl(),
            params: describeFeatureTypeParams,
            method: 'GET',
            success: function(response) {
                me.setLoading(false);
                if (Ext.isString(response.responseText)) {
                    featureTypes = Ext.decode(response.responseText);
                } else if (Ext.isObject(response.responseText)) {
                    featureTypes = response.responseText;
                } else {
                    Ext.log.error('Error! Could not parse ' +
                        'describe featuretype response!');
                }
                me.fireEvent('describeFeatureTypeResponse', featureTypes);
            },
            failure: function(response) {
                me.setLoading(false);
                Ext.log.error('Error on describe featuretype request:',
                    response);
            }
        });
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-getFeatures'>    /**
</span>     * Called by describeFeatureTypeResponse event fired by successfull
     * describeFeatureTypes() response.
     *
     * This method requests the actual features fitting to the search term.
     *
     * @param {Object} resp The ajax response containing DescribeFeatureType.
     */
    getFeatures: function(resp) {
        var me = this;
        var featureTypes = resp.featureTypes;
        var cleanedFeatureType = me.cleanUpFeatureDataTypes(featureTypes);
        var url = me.getCombo().getWfsServerUrl();
        var xml = me.setupXmlPostBody(cleanedFeatureType);
        var features;

        me.setLoading(true);

        Ext.Ajax.request({
            url: url,
            method: 'POST',
            headers: BasiGX.util.CSRF.getHeader(),
            xmlData: xml,
            success: function(response) {
                me.setLoading(false);
                if (Ext.isString(response.responseText)) {
                    features = Ext.decode(response.responseText).features;
                } else if (Ext.isObject(response.responseText)) {
                    features = response.responseText.features;
                } else {
                    Ext.log.error('Error! Could not parse ' +
                        'GetFeature response!');
                }
                me.fireEvent('getFeatureResponse', features);
            },
            failure: function(response) {
                me.setLoading(false);
                Ext.log.error('Error on GetFeature request:',
                    response);
            }
        });
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-cleanUpFeatureDataTypes'>    /**
</span>     * This method removes unwanted dataTypes from the passed ones.
     *
     * Called by getFeatures() for less vulnerability
     *
     * @param {Array&lt;Object&gt;} featureTypes The featuretypes.
     * @return {Array&lt;Object&gt;} The wanted typenames.
     */
    cleanUpFeatureDataTypes: function(featureTypes) {
        var me = this;
        var cleanedFeatureType = [];
        Ext.each(featureTypes, function(ft, index) {
            cleanedFeatureType.push({
                typeName: ft.typeName,
                properties: []
            });

            Ext.each(ft.properties, function(prop) {
                if (Ext.Array.contains(
                    me.getAllowedFeatureTypeDataTypes(), prop.type) &amp;&amp;
                    prop.name.indexOf(' ') &lt; 0) {
                    cleanedFeatureType[index].properties.push(prop);
                }
            });
        });
        return cleanedFeatureType;
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-setupXmlPostBody'>    /**
</span>     * Sets up a XML as string for a 'wfs:GetFeature'-operation.
     *
     * Called by #getFeatures to build the POST Body. It decides if the search
     * should be done in the visible extent only.
     *
     * @param {Array&lt;Object&gt;} featureTypes The featuretypes.
     * @return {String} The XML.
     */
    setupXmlPostBody: function(featureTypes) {
        var me = this;

        var limitToBBox = me.getCombo().getLimitToBBox();

        var map = BasiGX.util.Map.getMapComponent().getMap();
        var projection = map.getView().getProjection().getCode();
        var bbox;
        var visibleExtent = map.getView().calculateExtent(map.getSize());
        var totalExtent = map.getView().getProjection().getExtent();

        if (limitToBBox) {
            bbox = visibleExtent;
        } else {
            bbox = totalExtent;
        }

        var bboxll = bbox[0] + ' ' + bbox[1];
        var bboxur = bbox[2] + ' ' + bbox[3];

        var xml =
            '&lt;wfs:GetFeature service=&quot;WFS&quot; version=&quot;1.1.0&quot; ' +
              'outputFormat=&quot;application/json&quot; ' +
              'xmlns:wfs=&quot;http://www.opengis.net/wfs&quot; ' +
              'xmlns:ogc=&quot;http://www.opengis.net/ogc&quot; ' +
              'xmlns:gml=&quot;http://www.opengis.net/gml&quot; ' +
              'xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; ' +
              'xsi:schemaLocation=&quot;http://www.opengis.net/wfs ' +
              'http://schemas.opengis.net/wfs/1.1.0/WFS-basic.xsd&quot;&gt;';

        Ext.each(featureTypes, function(ft) {
            Ext.each(ft.properties, function(prop) {
                xml +=
                    '&lt;wfs:Query typeName=&quot;' + me.getCombo().getWfsPrefix() +
                           ft.typeName + '&quot;&gt;' +
                     '&lt;ogc:Filter&gt;' +
                      '&lt;ogc:And&gt;' +
                       '&lt;ogc:BBOX&gt;' +
                        '&lt;gml:Envelope srsName=&quot;' + projection + '&quot;&gt;' +
                         '&lt;gml:lowerCorner&gt;' + bboxll + '&lt;/gml:lowerCorner&gt;' +
                         '&lt;gml:upperCorner&gt;' + bboxur + '&lt;/gml:upperCorner&gt;' +
                        '&lt;/gml:Envelope&gt;' +
                       '&lt;/ogc:BBOX&gt;' +
                       '&lt;ogc:PropertyIsLike wildCard=&quot;*&quot; singleChar=&quot;.&quot;' +
                        ' escape=&quot;\\&quot; matchCase=&quot;false&quot;&gt;' +
                        '&lt;ogc:PropertyName&gt;' +
                         prop.name +
                        '&lt;/ogc:PropertyName&gt;' +
                        '&lt;ogc:Literal&gt;' +
                         '*' + me.searchTerm + '*' +
                         '&lt;/ogc:Literal&gt;' +
                       '&lt;/ogc:PropertyIsLike&gt;' +
                      '&lt;/ogc:And&gt;' +
                     '&lt;/ogc:Filter&gt;' +
                   '&lt;/wfs:Query&gt;';
            });
        });

        xml += '&lt;/wfs:GetFeature&gt;';

        return xml;
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-showSearchResults'>    /**
</span>     * This method parses the features and adds them to the store to show the
     * search results in the grid.
     *
     * Called by getFeatureResponse event fired by successfull response of
     * the method #getFeatures.
     *
     * @param {Array&lt;ol.Feature&gt;} features The features.
     */
    showSearchResults: function(features) {
        var me = this;
        var combo = me.getCombo();
        var parser = new ol.format.GeoJSON();

        if (!features) {
            Ext.log.error('No feature found');
        } else {
            if (features.length &gt; 0) {
                me.show();
            }

            var searchTerm = me.searchTerm;
            Ext.each(features, function(feature) {
                var featuretype = feature.id.split('.')[0];
                var displayfield;

                // find the matching value in order to display it
                Ext.iterate(feature.properties, function(k, v) {
                    var lowercaseVal = v &amp;&amp; v.toString().toLowerCase();
                    if (lowercaseVal &amp;&amp; lowercaseVal.indexOf(searchTerm) &gt; -1) {
                        displayfield = v;
                        return false;
                    }
                });

                feature.properties.displayfield = displayfield;
                feature.properties.featuretype = featuretype;

                var olFeat = parser.readFeatures(feature, {
                    dataProjection: combo.getWfsDataProjection(),
                    featureProjection: combo.getWfsFeatureProjection()
                })[0];
                me.searchResultVectorLayer.getSource().addFeature(olFeat);

            });
        }

    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-onBoxReady'>    /**
</span>    * called by OnBoxready listener to add search layer
    */
    onBoxReady: function() {
        var me = this;
        if (!me.getMap()) {
            var map = BasiGX.util.Map.getMapComponent().getMap();
            me.setMap(map);
        }
        if (!me.getLayer()) {
            var layer = new ol.layer.Vector({
                source: new ol.source.Vector()
            });
            var displayInLayerSwitcherKey =
                BasiGX.util.Layer.KEY_DISPLAY_IN_LAYERSWITCHER;
            layer.set(displayInLayerSwitcherKey, false);
            me.setLayer(layer);
            me.getMap().addLayer(layer);
        }
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-unregisterListeners'>    /**
</span>    * called by OnHide to deactivate all listeners when not needed
    */
    unregisterListeners: function() {
        var me = this;

        me.un('boxready', me.onBoxReady, me);
        me.un('itemmouseenter', me.highlightFeature, me);
        me.un('itemmouseleave', me.unhighlightFeature, me);
        me.un('itemclick', me.highlightSelectedFeature, me);

    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-highlightFeature'>    /**
</span>     * Called by onitemmouseenter listener to highlight the hovered search
     * results on the map.
     *
     * @param {Ext.grid.Panel} tableView The grid panel (`Ext.view.View`).
     * @param {Ext.data.Model} record The record that belongs to the item.
     */
    highlightFeature: function(tableView, record) {
        var me = this;
        var layer = me.getLayer();
        layer.getSource().clear();

        var feature = record.getFeature();

        if (feature) {
            this.flashListenerKey = BasiGX.util.Animate.flashFeature(
                feature, 1000);
            feature.setStyle(me.getSearchResultHighlightFeatureStyle());
            layer.getSource().addFeature(feature);
        }
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-unhighlightFeature'>    /**
</span>     * Called by onitemmouseleave listener to unhighlight the search
     * results on the map.
     *
     * @param {Ext.grid.Panel} tableView The grid panel (`Ext.view.View`).
     * @param {Ext.data.Model} record The record that belongs to the item.
     */
    unhighlightFeature: function(tableView, record) {
        var me = this;
        var layer = me.getLayer();
        layer.getSource().clear();

        var feature = record.getFeature();

        if (feature) {
            feature.setStyle(me.getSearchResultFeatureStyle());
        }

    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-highlightSelectedFeature'>    /**
</span>     * Called by onitemclick listener to center map on clicked item.
     *
     * @param {Ext.grid.Panel} tableView The grid panel (`Ext.view.View`).
     * @param {Ext.data.Model} record The record that belongs to the item.
     */
    highlightSelectedFeature: function(tableView, record) {
        var me = this;
        var layer = me.getLayer();
        var feature = record.getFeature();
        var extent;
        var x;
        var y;

        layer.getSource().clear();

        if (feature) {
            feature.setStyle(me.getSearchResultSelectFeatureStyle());
            layer.getSource().addFeature(feature);
            extent = feature.getGeometry().getExtent();
            x = extent[0] + (extent[2] - extent[0]) / 2;
            y = extent[1] + (extent[3] - extent[1]) / 2;

            me.getMap().getView().setCenter([x, y]);
        }

    }

});
</pre>
</body>
</html>
